= TunedIn - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-T14-B2/main

By: `The TunedIn Team`      Since: `Jun 2016`      Licence: `MIT`

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagramV1-4.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `CalendarView` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagramV1-4.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `GeneralBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.1 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagramV1-4.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* stores the Event Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` and `ObservableList<ReadOnlyEvent>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagramV1-4.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.
* can save the Event data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

//@@author keloysiusmak
// tag::alias[]
=== Alias mechanism

The alias mechanism is facilitated by `AliasSettings`, which resides inside `Commons > Core`. It supports the setting of custom aliases for the CLI commands in the TunedIn application, and the utilization of these custom set aliases to execute the command calls.

`AliasSettings` only deals with `Alias` and `HashSet`.

The following diagram shows the inheritance diagram for `AliasSettings`:

image::AliasClassDiagram.png[width="800"]

As you can see from the diagram, `AliasSettings` stores the custom set aliases for the various commands, and for efficiency, we also store the list of all protected aliases in a HashSet. This `AliasSettings` is then loaded into the TunedIn application, which is then passed into the AddressBookParser, when determining which commands to execute.

The implementation of the constructor for the Alias class is shown below in greater detail. `AliasSettings` stores individually the `Alias` object for every programmed function. As you can see, Alias requires the two inputs to be a `String`. The first input, `aliasCommand`, stores the default alias for the commands, while the second input stores the custom set alias for the particular command. It is precisely because of this reason that all the default aliases for the commands are set henceforth as protected aliases and cannot be set as an alias for a particular command.

[source,java]
----
public Alias(String aliasCommand, String aliasString) {
    try {
        requireAllNonNull(aliasCommand, aliasString);
        if (!(aliasCommand instanceof String && aliasString instanceof String)) {
            throw new IllegalValueException(MESSAGE_ALIAS_CONSTRAINTS);
        }
        this.aliasCommand = aliasCommand;
        this.aliasString = aliasString;
    } catch (IllegalValueException e) {
        ;
    }
}
----

When AliasSettings are loaded into the AddressBookParser, it is easy to control whether custom aliases are allowed for a particular function. The first shows how a custom alias can be allowed for a particular command, while the second showing the same function, with the alias capabilities removed, allowing only the default alias :
[source,java]
----
if (commandWord.equals(AddCommand.COMMAND_WORD)
        || commandWord.equals(aliasSettings.getAddCommand().getAlias())) {
    return new AddCommandParser().parse(arguments);
}
----

[source,java]
----
if (commandWord.equals(AddCommand.COMMAND_WORD)) {
    return new AddCommandParser().parse(arguments);
}
----

Suppose that the user has just launched the application. The `AliasSettings` will initialize with the default aliases.

The user executes a new `setalias` command by calling `setalias c\help al\h`, to set the alias for `help` to 'h'. The private `Alias` helpCommand variable will be replaced with a new `Alias` object, initialized with the values of 'help' and 'h'. Because help is a protected alias, it will not be removed from the HashSet, which is then used later to detect for duplicate aliases.

image::ReplacingHelpDiagram.png[width="800"]

The user executes another `setalias` command by calling `setalias c\help al\z`, to set the alias for `help` to 'z'. The private `Alias` helpCommand variable will be replaced again with a new `Alias` object, initialized with the values of 'help' and 'z'. Because the previously set alias, h, is not a protected alias in the HashSet, it will be replaced with h

image::ReplacingHelpDiagram2.png[width="800"]

When setting a new alias by calling `setalias c\help al\x` for example, the proposed new alias is checked within the HashSet for any conflicts. If it exists within the HashSet, no new Alias object will be created.

image::FailedReplacingDiagram.png[width="800"]

The following sequence diagram shows how the setalias operation works:

image::SetAliasSequenceDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `AliasSettings` when a user executes a new command:

image::SetAliasActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Looking for duplicates of Aliases +
**Alternative 1 (current choice):** Store the list of all used aliases in a HashSet +
**Pros:** Checking whether an alias exists in a HashSet is fast. +
**Cons:** The list stores the same data as the Alias objects, so it takes up marginally more space +
**Alternative 2:** Iterate individually through all the Aliases +
**Pros:** Does not require the creation of additional data structures to store the aliases +
**Cons:** Manually iterating through the list of `Alias` objects will take a long time.

---

**Aspect:** Viewing of currently set aliases +
**Alternative 1 (current choice):** Opens the list of currently set alias in a new window +
**Pros:** Much clearer to see which alias belongs to which command. +
**Cons:** Requires a couple more clicks to view the alias data, and subsequently a couple more clicks to resume regular TunedIn application usage. +
**Alternative 2:** Shows the list of currently set aliases in the current display window. +
**Pros:** Data is obtained instantly. +
**Cons:** It is hard to display in a presentable way the list of currently set aliases in textual format.

---

**Aspect:** Data structure to support the AliasSettings +
**Alternative 1 (current choice):** Use the same preferences.json file used to store GuiSettings +
**Pros:** Easy to port settings to another computer. Reduces the risk of file corruption or accidental file deletion. +
**Cons:** Potential to corrupt GuiSettings if AliasSettings are improperly stored. +
**Alternative 2:** Create a separate json file to store `AliasSettings` +
**Pros:** It is a lot clearer to see whether the AliasSettings are stored, and also any corruption of it will not affect the rest of the preferences. +
**Cons:** Creates a separate file for alias settings which could be grouped under the umbrella of preferences. +
// end::alias[]
//@@author

// tag::event[]
=== Event mechanism

The event mechanism is facilitated by `EventBook`, which resides inside `ModelManager`. It supports the additional
features of event management, which allows the user to add, edit, delete, find, or select event.
// end::event[]

// tag::export[]
=== Export mechanism

The export mechanism is facilitated by `XmlFileStorage`, which resides inside `StorageManager`. It allows the user
to export either their addressbook or eventbook in a excel format.
//end::export[]

// tag::find[]
=== Find From All Text Fields Mechanism

The existing find command is enhanced to allow the user to search for text in multiple fields. Previously, users can
only search for the contact by the name. However, with this mechanism, a user can find texts in the contact's name,
address, or mixed fields which principally mean all the text fields such as name, address, birthday, phone number and
remarks *EXCEPT* for tag names.

This leads to the change in the command's syntax. Here is the new syntax: `find <ATTRIBUTE>/KEYWORD [MORE KEYWORDS]`.
Here, `<ATTRIBUTE>` can either be `n`, `a` or `m`.

The change the format of the command leads to the changes in the FindCommandParser.parse() method:

[source, java]
----
    public FindCommand parse(String args) throws ParseException {
        String trimmedArgs = args.trim();
        if (trimmedArgs.isEmpty()) {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
        if (trimmedArgs.charAt(0) == 'n') {
            NameContainsKeywordsPredicate.setPredicateType('n');
        } else if (trimmedArgs.charAt(0) == 'a') {
            NameContainsKeywordsPredicate.setPredicateType('a');
        } else if (trimmedArgs.charAt(0) == 'm') {
            NameContainsKeywordsPredicate.setPredicateType('m');
        } else {
            throw new ParseException (
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        trimmedArgs = trimmedArgs.substring(2).trim();
        String[] nameKeywords = trimmedArgs.split("\\s+");

        return new FindCommand(new NameContainsKeywordsPredicate(Arrays.asList(nameKeywords)));
    }
----

The code shows how the command is being processed based on the attribute character. Namely, if the attribute is n, the
find will look for keywords in the name. If the attribute is a, the command will find in the address. Lastly, if the
attribute is m, the command will find in all text fields.

In the future, this feature can be developed into a best-matched search based on different fields whereby the contact
that matches the most fields will appear first followed by the one matching second most fields. Users are allowed to
set the number of results to appear.
//end::find[]

// tag::group[]
=== Group mechanism

The group mechanism is facilitated by the `Person`, which resides inside the 'Addressbook'.
It supports adding a custom group to a number of contacts by utilizing the CLI commands in the TunedIn application.

Group is stored as an attribute of Person. Each person will have an empty or a group.

The implementation of the `Group` command constructor is shown below : +
insert diagram

As you can see from the implementation, Group command require two type of inputs in the form of `Index` and `Group`.
The first input in the form of `List<Index>` stores a list of index(es) correspond to the person(s) to be grouped. The
second input in the form of Group stores the group name specified by the user.

The implementation of storing group into individual person is as shown : +
insert code.

Suppose that the user has just launched the application.
Assuming a valid addressbook xml file exists (with numerous person data in it),
the UniquePersonList will start storing a list of Person object with correspondence to the xml file.
Each person will either have a textual or empty `Group`.

The user executes a `group` Command by calling `group 1 2 g/TEST1`, to set the 1st and 2nd person’s group to "TEST1" in the address book.
The existing `group` will be replaced by the user input "TEST1" and the Persons’ object will be updated.

The user then executes another `group`Command by calling `group 2 3 4 5 g/ to ungroup the 2nd to 5th person.

[NOTE]
If the group command fails its execution due to invalid index(es), the list of person(s) will not be grouped.

The following sequence diagram shows how the group operation works: //insert sequence diagram.


`list` command will be enhanced with group feature, allowing user to list contacts of a specified group.
// end::group[]

//tag::list[]
=== List(group) mechanism
//To be completed by tingtx
//end::list[]

// tag::order[]
=== Order(Sort) mechanism
The order mechanism is facilitated by the `orderBy` method, which resides inside the `UniquePersonList > Person > Addressbook`. It supports
the ordering(sorting) of the contact list by utilizing the CLI commands in the TunedIn application. +

`OrderCommand` supports
undoing and redoing of command and inherit from the `UndoableCommands`. The following diagram shows the inheritance
diagram for the command: //insert diagram +

The implementation of the `order` command constructor is as shown : //insert code +

As you can see from the implementation, the command requires user inputs in the form of 'String' as the paramater/s
to order. The inputs are restricted by the fields of `Person` which only includes `Name`, `Address`,
`Tag` and `Birthday`. The command is able to order by a maximum of two parameters. It will order the list by
the first parameter follow by the second parameter.

The implementation of the ordering mechanism is shown below: //insert code +

As you can see, 4 `Comparator` object are constructed for each valid parameter to compare the list of contacts
and order according to natural order. +

[NOTE]
`Birthday` is ordered by yyyy-mm-dd instead of the dd-mm-yyyy format. +
This is achieved by reformatting the
 `Birthday` string as shown: //insert code
 +
 Person(s) with empty `Birthday` field will be sorted to the last.

Suppose that the user has just launched the application and no previous `order` command has been called. The contacts will
be listed according to the default ordering, in order of the order a particular contact is added (Last contact added will appear as the last in the list).


The user executes another `order` command by typing `order name`, to view the list of contacts ordered in alphabetical order
based on the `Name` field of a person. With valid input the list of contacts will be ordered accordingly and
the ordered list will be shown.

The user executes another command by typing `order tag name` to order the list by `Tag` first then `Name` of the person.

[NOTE]
If the order command fails its execution due to invalid order parameter, the list of contact will
not be ordered.

The following sequence diagram shows how the order operation works: //insert sequence diagram.
// end::order[]

// tag::remark[]
=== Remark mechanism

The remark mechanism is facilitated by `Person`, which resides inside `Addressbook`. It supports adding a custom remark to individual contact
by utilizing the CLI commands in the Tunedln application.

`Person` only deals with `Name`, `Phone`, `Email`, `Address`, `Birthday`, `Remark`, and `Tags`.

The following diagram shows the inheritance diagram for `Person`:

image::RemarkClassDiagram.png[width="800"]

As you can see from the diagram, Person stores the remark as an attribute. This Person object is then stored in the
UniquePersonList, which resides in the AddressBook.

The implementation of the constructor Remark class is shown below in greater detail. Each person in the UnqiuePersonList will have
either an empty or textual remark. As you can see from the implementation, Remark require one String input. This input
will be provided by the user (which is also owner of the Addressbook), and it will override the existing Remark value (*Note: Empty String is also allowed).
Note that this technique of abstraction allows us to further expand Remark into different smaller class to display
out a more detailed Remark (E.g. let's take Address class for instance, it could consists of Block, Street, UnitNo, Postal).

[source, java]
----
  public Remark(String remark) {
        requireNonNull(remark);
        this.value = remark;
    }
----

The implementation of storing Remark into a Person object is shown below:

[source, java]
----
    public Person(Name name, Phone phone, Email email, Address address, Birthday birthday, Remark remark,
                  Set<Tag> tags) {
        requireAllNonNull(name, phone, email, address, birthday, tags);
        this.name = new SimpleObjectProperty<>(name);
        this.phone = new SimpleObjectProperty<>(phone);
        this.email = new SimpleObjectProperty<>(email);
        this.address = new SimpleObjectProperty<>(address);
        this.birthday = new SimpleObjectProperty<>(birthday);
        this.remark = new SimpleObjectProperty<>(remark);

        // protect internal tags from changes in the arg list
        this.tags = new SimpleObjectProperty<>(new UniqueTagList(tags));
    }
----

Suppose that the user has just launched the application. Assuming a valid addressbook xml file exists (with numerous person data in it),
the UniquePersonList will start storing a list of Person object with correspondence to the xml file. Each person will either have a textual or empty remark.

The user executes an `edit` Command by calling `edit 1 r/1st try`, to set the 1st person's
remark to "1st try" in the address book. The existing Remark value will be replaced by the user input "1st try" and
the 1st Person's object will be updated, since the Remark object is referencing to the 1st Person's remark attribute.

image::ReplacingRemarkDiagram.png[width="800"]

The user executes another edit command by calling `edit 1 r/2nd try`, to replace the remark initial value which is
"1st try" to "2nd try".

image::ReplacingRemarkDiagram2.png[width="800"]

[NOTE]
If the edit command fails its execution due to unacceptable syntax, the person's remark will not be replaced.


The following sequence diagram shows how the edit remark operation works:

image::ReplacingRemarkSequence.png[width="800"]


The following activity diagram summarize what happens inside the `Person` when a user executes a new command:

image::ReplacingRemarkActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of Remark +
**Alternative 1 (current choice):** Replace the existing Person object with an edited
Person object. +
**Pros:** Neat and Clearer abstractions to be displayed in class diagram. +
**Cons:** Tedious, as the implementation could have be simpler by assigning String as Remark attribute. +
**Alternative 2:** Let String be the attribute for Remark +
**Pros:** Easy to implement. +
**Cons:** Harder to understand the flow of the implementation.

---

**Aspect:** Viewing of Remark
**Alternative 1 (current choice):** Only one remark is able to store for one contact. +
**Pros:** Easy to implement. +
**Cons:** User is unable to keep more than 1 remark. +
**Alternative 2:** Data structure to support multiple remark. +
**Pros:** User is given the choice to overwrite or save a new remark. +
**Cons:** Harder to implement.

// end::remark[]
---


// tag::theme[]
//@@author keloysiusmak
=== Theme mechanism

The theme mechanism will facilitated by `ThemeSettings`, which resides inside `Commons > Core`. It supports the setting
of custom preset themes for the TunedIn application.

---

Themes will persist even after closing the app, allowing the user to use the application the way he desires.
// end::theme[]
//@@author

// tag::lock[]
=== Lock Mechanism

The addressbook.xml file will be encrypted to protect the confidentiality of the data. Contacts are encrypted in
separate files named by the user's `USERNAME` and encrypted by the user's `PASSWORD`. If the contacts are open to the
public, it will be in the `PUBLIC.encrypted` file, which is encrypted with the password `PUBLIC`. Every time TunedIn
runs, it will decrypt the `PUBLIC.encrypted` file with the `PUBLIC` password and write the data into the
addressbook.xml file for the rest of the program to load up. Once a mutating operation is done to the addressbook.xml
file, the `save` command must be executed afterwards for the changes to be saved to the encrypted files. Till date,
most of the mutating commands are incorporated with the `save` command, but users are advised to save manually in
case of bugs or unincorporated commands.

The `lock` command will enable a user to lock the current list of contacts using a user account comprising a user
name and a password. The user credentials will then be persisted into the account.xml file as SHA-256 hash digests .
In particular, User name will be hashed and stored directly into the account.xml file. Each user will be given a
randomised salt value, which will be hex-coded and stored in the account.xml file. The password will first be
prepended with the salt value from that user, after which the combined string will be hashed and stored. In this way,
users with the same passwords will have different hash digests, upholding the confidentiality of the information.

When the user uses the lock command, he/she needs to supply the `USERNAME` and `PASSWORD` to create an account. The
program will then hash the `USERNAME` and compare with the existing user name hash digests from the file. If the hash
values are the same, a `DuplicateUserException` exception will be thrown.

Once an account is registered under the lock command, the current list of contacts will be to encrypt with the user's
password. When a user uses the lock command, he/she will be logged in as that newly-created user. To change to
another account, the user has to log out first. Once user has locked the contact and logged out, the list of contacts
will be emptied, the addressbook.xml file will be encrypted with the user's password and named with the first 10
characters of that user's username hex digest and a new empty addressbook.xml file will be created. Once logged
out, the current user is set to public. To log in with a registered user, use the log in command `login u/USERNAME
p/PASSWORD` which requires the user to supply the `USERNAME` and `PASSWORD` for verification. The programme then
verifies if the credentials are correct with the account.xml file. Finally, it will decrypt the contacts of that user
using the plaintext of the supplied password.

image::LockMechanism.jpg[width="800"]

The HashDigest.java in the digestutil package will apply the SHA-256 hash algorithm on a plaintext and return the
message digest as a String

[source,java]
----
/**
 * Converts a string to a SHA-256 Hash Digest.
 */
public class HashDigest {
    /**
     * Return the hash digest of {@code text}. Used for creating accounts and validating log-ins.
     */
    public byte[] getHashDigest(String text) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance("SHA-256");
            return digest.digest(text.getBytes(StandardCharsets.UTF_8));
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
    }
}
----

The generation of salt and how the password digest is done are implemented in the LockCommand.java file as follows

[source,java]
----
@Override
    public CommandResult execute() throws CommandException, DuplicateUserException {
        requireNonNull(model);
        byte[] uIdDigest = new HashDigest().getHashDigest(userId);
        byte[] salt = new byte[32];
        final Random r = new SecureRandom();
        r.nextBytes(salt);
        String saltText = new String(salt);
        byte[] pwDigest = new seedu.address.logic.commands.digestutil.HashDigest()
                .getHashDigest(saltText + passwordText);
        String hexUidDigest = getHexFormat(uIdDigest);
        String hexSalt = getHexFormat(salt);
        String hexPassword = getHexFormat(pwDigest);
        try {
            model.persistUserAccount(new User(hexUidDigest, hexSalt, hexPassword));
        } catch (DuplicateUserException due) {
            throw new CommandException(MESSAGE_EXISTING_USER);
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }
----

The conversion of the salts and digests into hexadecimal strings is handled by the HexCode.java file
[source,java]
----
/**
 * Provide the utilities to obtain hex strings from texts and texts from hex strings
 */
public class HexCode {

    /**
     * Return hex string of text
     */
    public String getHexFormat(String text) {
        char[] chars = text.toCharArray();

        StringBuffer hex = new StringBuffer();
        for (int i = 0; i < chars.length; i++) {
            hex.append(Integer.toHexString((int) chars[i]));
        }

        return hex.toString();
    }

    /**
     * Return text of hex string
     */
    public String hexStringToByteArray(String hexString) {
        StringBuilder sb = new StringBuilder();
        StringBuilder temp = new StringBuilder();

        for (int i = 0; i < hexString.length() - 1; i += 2) {

            //grab the hex in pairs
            String output = hexString.substring(i, (i + 2));
            //convert hex to decimal
            int decimal = Integer.parseInt(output, 16);
            //convert the decimal to character
            sb.append((char) decimal);

            temp.append(decimal);
        }
        System.out.println("Decimal : " + temp.toString());

        return sb.toString();
    }
}
----
The encryption and decryption of the files are done in the FileEncryptor.java file of the logic.command.encryption

[source,java]
----
/**
 * This provides encryption and decryption utilities
 */
public class FileEncryptor {
    private static final byte[] salt = {
        (byte) 0x43, (byte) 0x76, (byte) 0x95, (byte) 0xc7,
        (byte) 0x5b, (byte) 0xd7, (byte) 0x45, (byte) 0x17
    };

    private static final String addressBookFilePath = "data/addressbook.xml";

    /**
     * Create a cipher
     *
     * @param pass        passphrase
     * @param encryptMode true for encryption, false for decryption
     * @return a cipher object
     * @throws GeneralSecurityException
     */
    private static Cipher makeCipher(String pass, Boolean encryptMode) throws GeneralSecurityException {

        //Use a KeyFactory to derive the corresponding key from the passphrase:
        PBEKeySpec keySpec = new PBEKeySpec(pass.toCharArray());
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
        SecretKey key = keyFactory.generateSecret(keySpec);

        //Create parameters from the salt and an arbitrary number of iterations:
        PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 42);

        //Set up the cipher:
        Cipher cipher = Cipher.getInstance("PBEWithMD5AndDES");

        //Set the cipher mode to decryption or encryption:
        if (encryptMode) {
            cipher.init(Cipher.ENCRYPT_MODE, key, pbeParamSpec);
        } else {
            cipher.init(Cipher.DECRYPT_MODE, key, pbeParamSpec);
        }

        return cipher;
    }

    /**
     * Encrypts one file to a second file using a key derived from a passphrase:
     */
    public static void encryptFile(String userId, String pass, boolean emptyFile)
            throws IOException, GeneralSecurityException {
        byte[] decData;
        byte[] encData;
        File inFile = new File(addressBookFilePath);
        //Generate the cipher using pass:
        Cipher cipher = FileEncryptor.makeCipher(pass, true);

        //Read in the file:
        FileInputStream inStream = new FileInputStream(inFile);

        int blockSize = 8;
        //Figure out how many bytes are padded
        int paddedCount = blockSize - ((int) inFile.length() % blockSize);

        //Figure out full size including padding
        int padded = (int) inFile.length() + paddedCount;

        decData = new byte[padded];


        inStream.read(decData);

        inStream.close();

        //Write out padding bytes as per PKCS5 algorithm
        for (int i = (int) inFile.length(); i < padded; ++i) {
            decData[i] = (byte) paddedCount;
        }

        //Encrypt the file data:
        encData = cipher.doFinal(decData);


        //Write the encrypted data to a new file:
        FileOutputStream outStream = new FileOutputStream(new File("data/" + userId + ".encrypted"));
        outStream.write(encData);
        outStream.close();

        if (emptyFile) {
            outStream = new FileOutputStream(new File("data/addressbook.xml"));
            String emptyContent = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n"
                    + "<addressbook/>\n";
            outStream.write(emptyContent.getBytes());
            outStream.close();
        }
    }

    /**
     * Decrypts one file to a second file using a key derived from a passphrase:
     */
    public static void decryptFile(String fileName, String pass)
            throws GeneralSecurityException, IOException {
        byte[] encData;
        byte[] decData;
        File inFile = new File("data/" + fileName + ".encrypted");

        //Generate the cipher using pass:
        Cipher cipher = FileEncryptor.makeCipher(pass, false);

        //Read in the file:
        FileInputStream inStream = new FileInputStream(inFile);
        encData = new byte[(int) inFile.length()];
        inStream.read(encData);
        inStream.close();
        //Decrypt the file data:
        decData = cipher.doFinal(encData);

        //Figure out how much padding to remove

        int padCount = (int) decData[decData.length - 1];

        //Naive check, will fail if plaintext file actually contained
        //this at the end
        //For robust check, check that padCount bytes at the end have same value
        if (padCount >= 1 && padCount <= 8) {
            decData = Arrays.copyOfRange(decData, 0, decData.length - padCount);
        }
        //Write the decrypted data to a new file:

        FileOutputStream target = new FileOutputStream(new File("data/addressbook.xml"));
        target.write(decData);
        target.close();
    }
}
----

Further more, users can check out who the current user is. The default user is `PUBLIC` which means no user has
logged in and the address book is open to the public. The command is `currentuser` and the result is a display saying
`Current user is: <USERNAME>`. The CurrentUserDetails class describes the `UserNameText`, the `UserNameHexDigest`,
the `SaltHex` and the `PasswordHexDigest` of the current user. It is stored int the logic.command.currentuser package

[source,java]
----
/**
 * Describe the current user
 */
public class CurrentUserDetails {
    private static String userId = "PUBLIC";
    private static String userIdHex = "";
    private static String saltText = "";
    private static String passwordText = "";

    public static void setCurrentUser(String userId, String userIdHex, String saltText, String passwordText) {
        CurrentUserDetails.userId = userId;
        CurrentUserDetails.userIdHex = userIdHex;
        CurrentUserDetails.saltText = saltText;
        CurrentUserDetails.passwordText = passwordText;
    }

    public static void setPublicUser() {
            userId = "PUBLIC";
            userIdHex = "PUBLIC";
            saltText = "";
            passwordText = "PUBLIC";
        }
}
----

**Design Considerations:** +
**Aspect:** Separation of addressbook.xml file into usercontact files +
**Description:** Save the contacts that belong to a user in a separate file designated for that user only +
**Pros:** Ease of encryption, decryption and navigation. +
**Cons:** Greater overheads to manage multiple xml files which can interfere with other existing or incoming increments
to the program +

---
// end::lock[]

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size


=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |

|`* * *` |user |add remarks for a person |make notes for contacts

|`* * *` |user |set my own alias for commands |remember the commands easily

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |set certain contacts as favourites |access their information easily

|`* * *` |user |select multiple contacts to delete |clean up address book efficiently

|`* * *` |user |save more than one contact number per contact in my address book |account for multiple phone numbers

|`* * *` |organised user |group contacts manually or automatically |access the information I want easily

|`* * *` |user |save my contacts' birthdays |refer to it easily

|`* * *` |organized user |save events |refer to my events easily

|`* * *` |user with busy schedules |see my important events on a calendar view |have an overview of my schedule for the month

|`* * *` |organized user |share my contact details with my friends |save the contacts without manually keying in the details

|`* * *` |forgetful user |apply search keywords on all text fields of a contact |find my contacts from all text fields
and not just their names.

|`* * *` |impatient user |sort the information on the application |view the information in a ordered manner

|`* * *` |user |add information to the application in a intuitive way |feel less frustrating

|`* * *` |user |sync my account with other platforms |save the trouble of entering my personal details

|`* * *` |user |access my data over multiple authorized devices |avoid keying my data repeatedly across different platforms

|`* * *` |forgetful user |have my account logged in every time I open the app |do not have to remember one additional username and password

|`* * *` |forgetful user |set reminders |do not forget what I need to do

|`* * *` |user |export the list of people in my address book |store it on the computer

|`* * *` |user |set events and send the event invites to any person in my contact list |sync my calendars with others' on our common events

|`* * *` |user |attach personal notes to people in my contact list |take notes about the person for my own reference

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else
seeing them by accident

|`* *` |user |send mass messages to a group of contacts |plan for meetings, conferences or gatherings with ease

|`* *` |user |manage contacts in different groups |maintain control over my groups

|`* *` |user |view groups of contacts in a more visual display |see who are also in the group

|`* *` |user |commands to be in the button form |avoid memorising the commands and select them more easily

|`* *` |user |have meta-data for my contact list |sort them according to different criteria

|`* *` |user |the application not to take up too much space on my device |have space for other applications

|`* *` |user |the application should suggest certain fields for autocomplete |do not have to type them

|`* *` |user |easily send emails to my contacts |conveniently contact my friends

|`* *` |user |update my location |let my contacts know my current location

|`* *` |user |update my status |contacts will know whether I’m busy

|`* *` |user |view live stories of my friends |stay updated on what is going on with my friends

|`* *` |user |start a live chat with my friends |get an instant response from them

|`* *` |user |add a profile picture |let others know how I look like

|`* *` |user |change the colour scheme |make it personalized

|`* *` |user |choose not to cache the password after every login |ensure that the application is secure

|`* *` |user |access the applications quickly |be efficient with  what I do

|`* *` |user |avoid switching between applications for different functionality |avoid troublesome operations for me

|`* *` |user |add profiles for my friends |store their photos as well

|`* *` |user with many persons in the address book |sort persons by name |locate a person easily

|`*` |user |have a collage of a person's profile from various social media platforms |snapshot of the person's information
from various accounts.

|`*` |user |subscribe to different channels |get more information on the outside world

|`*` |user |play music in the background |feel relaxed while using the application

|`*` | elderly user |application to read the contacts out loud |avoid straining my eyes reading the words
|=======================================================================


[appendix]
== Use Cases

(For all use cases below, the *System* is the `TunedIn AddressBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete person

*Main Success Scenario*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to delete a specific person in the list
4.  AddressBook deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

=== Use case: Sync Account

*MSS*

1.  User requests to sync account
2.  TunedIn asks for Facebook ID
3.  User confirms that the account is of the user's
4.  TunedIn displays the data pulled from Facebook
+
Use case ends.

*Extensions*

[none]
* 2a. The Facebook ID does not exist
+
Use case ends.

* 3a. The given Facebook ID is inaccurate
+
[none]
** 3a1. TunedIn shows an error message.
+
Use case resumes at step 2.

=== Use case: Logging in

*MSS*

1.  User types in password
2.  TunedIn checks password accuracy
3.  User is brought to the home page
+
Use case ends.

*Extensions*

[none]
* 1a. The user has not logged in
+
[none]
** 1a1. TunedIn shows an error message.
** 1a2. TunedIn requests for user to log in.
+
Use case ends.

* 2a. The password is inaccurate
+
[none]
** 2a1. TunedIn shows an error message.
+
Use case resumes at step 2.

=== Use case: Setting a contact as favourite

*MSS*

1.  User selects a contact as favourite
2.  TunedIn sets the selected contact as favourite for original user
3.  Contact is set to the top of the contact list.
+
Use case ends.

*Extensions*

[none]
* 1a. The selected user does not exist
+
[none]
** 1a1. TunedIn shows an error message.
+
Use case resumes at step 1.

[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be lightweight and not take up too much storage space
.  Should be easy to use and be designed for cross platform use

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....
[[Alias]]

....
A shorthand for users to execute Command Line Instructions
....

[[app]]
App

....
Refers to the TunedIn application
....

[[user]]
User

....
Users of all ages and gender
....

[[mobile-devices]]
Mobile Devices

....
iPhone, Samsung, Huawei, Oppo and other major phone manufacturers.
....

[[private-contact-detail]]
Private contact detail

....
A contact detail that is not meant to be shared with others
....

[appendix]
//@@author keloysiusmak
== Product Survey

*Wunderlist*

Author: 6 Wunderkinder

Pros:

* Easy to create reminders
* Works seamlessly across all major devices
* Easy to collaborate with others
* Nice and clean design

Cons:

* Easy to be overwhelmed by the huge number of features
